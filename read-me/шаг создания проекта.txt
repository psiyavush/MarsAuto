1. Верстка главной страницы по макету: https://www.figma.com/file/RKWVwNdQEQbcXsOtOklOjG/Электромобили-в-Липецке-с-Прототипом
    заменил название, логотип и главную картинку на свои
    в верстке часто используется flex
    работа через scss
    так же создаю в яндекс картах - карту с заправками и подключаю её

2. Создание БД - db.json и заполнения первыми 3-я авто
    инструкция по созданию в текущей папке

3. Создаем в папке \IncoAuto\src\js файл cars.js
    этот скрипт выводит на главную страницу (section class="car") 3 авто(карточки) из БД
    Для реализации все что было написано в блоке section class="car" на главной странице (з карточки) - удалено,
    а структура карточки использована, как шаблон в cars.js
    т.к. на Главной выводится только 3 карточки в файле применен фильтр - .filter((item, i) => i<3), где i это индекс (см файл - Цикл do while и Методы МАССИВОВ forEach, find, findIndex, filter, map)
    также стоит обратить внимание на реализацию размножения блока - carContent.innerHTML += 

4. Создаем страницу с полным списком автомобилей из БД по адресу \IncoAuto\pages\catalog\index.html
    в этой же папке создаем скрипт файл cars.js для вывода всех авто из БД на эту страницу
    здесь такая же технология, как в шаге №3, но без ограничения по выводу авто из БД
    С главной страницы создаем ссылку на эту страницу в кнопке "Посмотреть все автомобили"

5. На странице каталога создаем кнопку Добавить, которая будет добавлять авто в каталог через всплывающее окно (PopUp)
    Для этого h2 (кнопка напротив h2) оборачиваем в div, чтобы можно было применить display: flex;  и justify-content: space-between;
    Для кнопки беру уже готовый класс из главной страницы class="header__btn" и добавляю к нему класс add_btn, чтобы можно было обратиться к кнопке из скрипта
    Создаю под footer, div - overlay, в нем div - popup, внутри форма - прописываю им стили. (autocomplete="off" - очищает историю форму)
    Получаю в js элементы: форма добавления авто, "Добавить автомобиль", элемент модального окна на добавления авто
    На событие отправки формы (submit) вызываем callback функцию, которое принимает событие e (Event)
    Отправляем запрос в БД на запись (Post) нового объекта, события e имеет target, где у каждого индекса формы из свое значение (value)
    Очищаем элемент, где выводим БД и снова заполняем элемент
    При нажатии на кнопку "Добавить автомобиль", делаем блок "overlay" видимым
    При нажатии на пустое место в блоке "overlay", делаем его невидимым

6. На странице каталога (непосредственно в функции getAllCars в последнем then, где формируется карточка) создаем кнопки Удалить, у каждой карточки авто (важный параметр кнопки data-id="${item.id}")
    в последнем then функции getAllCars, получаем все кнопки, перебираем их и на той, где будет событие клик - делаем запрос на удаление по id в ссылке

7. Сверстали страницу: Полезная информация (Папка pages/useful-info). Для хранения статей будем использовать базу. Поэтому в db.json создаем новый ключ: info и заполняем первыми карточками-статьями
    Создаем файл info.js и подключаем его к странице Полезная информация
    Получаем из DOM класс где будет выводиться информация о карточках ".useful-info__content" в переменную "infoContent"
    создаем функцию getAllInfo с атрибутом "number" (в этом атрибуте пагинация страницы) с fetch запросом к БД
    полученный запрос переворачиваем по выводу индексов (slice().reverse()) и фильтруем (filter) логикой: 
        i > number * 5 - 6 && i < number * 5 (здесь i - индекс карточки, а вся логика, чтобы выводились индексы записей в соответствии от номера пагинации и только 5 карточек на странице)
        затем перебираем полученные карточки и добавляем их в "infoContent", при этом у четных карточек меняем местами картинку с текстом (style="flex-direction: ${i%2===0 ? 'row' : 'row-reverse'}")
    Затем создаем сложную структуру логики для кнопок пагинации (если число карточек больше 5):
        создаем список "ul" для цифровых кнопок и даем ему класс (useful-info-list), а также два "span" для переключения между кнопками пагинации
        Так же от себя создал дополнительно два "span" для переключения пагинации в начало и конец (first и last)
        создаем цикл от переменной x=1 до x <= общему количеству карточек(info.length) деленному на пять с математическим округлением в большую сторону (Math.ceil), с шагом +1
        таким образом в "ul" отобразим список "li" с номерами страниц пагинации (если 16 карточек, то 16/5 с округлением в большую, получим 4 кнопки)
        За вывод числа кнопок (хотим чтобы отображалось максимум 3), отвечаем такая логика в свойстве display для li:
            если x = number(номер стр пагинации) или х+1 = number или х-1 = number то display: flex
            и если number = 1 и x = 3 или number = числу последней кнопки (Math.ceil(info.length / 5)) и х = числу последней кнопки минус 2 то display: flex
            иначе display: none
        Создаем логику появления стрелок next и last:
            если number (номер стр пагинации) чем число последней кнопки (Math.ceil(info.length / 5)) минус один, то появляется стрелка next (>) и стрелка last (>>) после списком пагинации
            добавляем событие клик на стрелку next, при котором чистим все карты и номера пагинации, а затем вызываем нашу основную функцию с атрибутом number+1
            добавляем событие клик на стрелку last, при котором чистим все карты и номера пагинации, а затем вызываем нашу основную функцию с атрибутом Math.ceil(info.length / 5) (последняя страница пагинации)
        Создаем логику появления стрелок prev и first:
            если number (номер стр пагинации) больше 2 то появляется стрелка prev (<) и стрелка first (<<) перед списком пагинации
            добавляем событие клик на стрелку prev, при котором чистим все карты и номера пагинации, а затем вызываем нашу основную функцию с атрибутом number-1
            добавляем событие клик на стрелку first, при котором чистим все карты и номера пагинации, а затем вызываем нашу основную функцию с атрибутом 1
        Устанавливаем наш список кнопок пагинации после infoContent - infoContent.after(ul)
    Делаем кликабельными все кнопки пагинации:
        сначала получаем их все по классу в переменную useful-info-item, затем если на какой из них происходит событие клик, то чистим все карты и номера пагинации
        и вызываем нашу основную функцию с атрибутом "item.dataset.id", который соответствует нажатой кнопки
8. Сверстали страницу: Справочный центр (Папка pages/center). Для подключения "Аккордеона" использовались стили (canter.scss) и код (center.js)
9. На страницу Полезная информация, добавлены кнопки удалить и добавить статью. По примеру страницы и кода из папки catalog.
10. Добавляем возможность изменения карточен на странице Полезная информация и Каталога. Фишка - используем тоже самое модальное окно, что и добавление информации
    Добавляем кнопку изменить к каждой карточке и прописываем им data-id
    Удаляем в модальном окне текст кнопки отправки формы
    добавляем логику, если клик был по кнопке Добавления информации, то текст кнопки отправки формы меняется на Добавить и наоборот, если по кнопке изменить, то текст меняется на изменить
    добавляем в модальное окно формы невидимое поле, в которое можем передать id записи
    также при клике по кнопке изменить:
        - создаем в переменные все поля формы
        - делаем модальное окно видимым
        - в поля формы заполняем информацию, полученную через вызов потомков родителя (или элемента до/после родителя) у кнопки Изменить
            (т.к. кнопка изменить у конкретного элемента в котором уже выведена информация)
        - создаем логику в форме добавления информации, если текст кнопки отправки формы был "изменить", то идет PATCH запрос, иначе POST запрос
    На странице Каталога, т.к. элементов много и большая вложенность, будем использовать другую логику, БОЛЕЕ правильную
        - также получаю все кнопки изменить, и по клику на одной из них меняем кнопки на - Изменить и отображаем модальное окно
        - также добавляем в модальное окно формы невидимое поле, в которое можем передать id записи
        - далее делаем Fetch запрос к БД по btn.dataset.id, которое есть у кнопки по которой кликнули
        - в результате получаем объект с данными по карточке, который затем заполняем в форму Изменения, вызывая элементы формы по id и заполняя их value из полученного объекта
        - так же создаем логику в форме добавления информации, если текст кнопки отправки формы был "изменить", то идет PATCH запрос, иначе POST запрос